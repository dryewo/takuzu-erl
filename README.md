# takuzu-erl

Программа генерации поля для игры [takuzu](http://en.wikipedia.org/wiki/Takuzu).

Живой пример игры можно испытать здесь: http://0hh1.com

## Использование

Для работы требуется установленный Erlang.

```
$ git clone https://github.com/dryewo/takuzu-erl.git && cd $_
$ erl
1> c(takuzu, {d, 'TEST'}), takuzu:test().
  All 15 tests passed.
ok

2> timer:tc(fun()->takuzu:generate(8) end).
Generation done, O:12, X:9
X O . O . . . . 
O . . O . X . . 
. O O . . . . . 
. . O . . . X O 
. . . . O . X . 
O . X . O . . . 
. . . O . . . . 
. X X . X . . X 

{152386,ok}
```

## Правила takuzu

1. Не может быть более двух одинаковых клеток рядом.
2. В каждой строке или столбце должно быть одинаковое количество X и O.
3. Не должно быть одинаковых строк или одинаковых столбцов.
4. Размер поля — четное число >= 4.

## Алгоритм решения

Последовательно применяем к полю любой из подходящих шагов:

1. Если есть комбинация `X . X`, заменяем её на `X O X`, аналогично `O . O` -> `O X O`, аналогично вертикальные комбинации.

2. Если есть комбинация `X X`, заменяем её на ` O X X O`, аналогично с `O O`, аналогично вертикальные.

3. Если есть строка, в которой ровно половина ячеек заполнена одинаково, заполняем оставшиеся дополняющим образом (`X . X O X .` -> `X O X O X O`). Аналогично столбцы.

4. Если есть строка с двумя незаполненными ячейками и заполненная строка, совпадающая с ней в заполненной части, заполняем пустующие две клетки наоборот, чтобы строки получились разные. Аналогично столбцы.

   ```
   X X O X O O        X X O X O O
   X . O X . O   ->   X O O X X O
   ```

Если на некотором этапе остались пустые клетки, но ни один из вариантов применить не удается, поле считается нерешаемым.

## Алгоритм генерации поля

Поле размера `N` представляется в виде списка длиной `N²`. Первые `N` элементов — первая строка, и так далее. Пустое поле размера 4 выглядит так:

```
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

`O` представляется как `1`.
`X` представляется как `2`.

Для генерации решаемого поля к пустому полю итеративно применяется следующая процедура:

- Пытаемся решить поле.
  * Если решение возможно, редуцируем поле (см. ниже) и возвращаем его.
  * Если нет, тогда заполняем одну клетку случайным образом и не нарушая правил, а затем применяем процедуру снова.

Редуцирование готового поля нужно для опустошения клеток, содержимое которых выводится из других клеток. В процессе случайной генерации поля появление таких комбинаций не исключено. Например:

  - `X X O` -> `X X .`
  - `O X O` -> `O . O`
  - `X O X X O .` -> `X . X X . .`

Для редуцирования выполняется поиск вариантов решения для всех *заполненных* клеток. Клетки, для которых вариант нашелся, опустошаются.

## License

Copyright © 2014 Dmitry Balakhonskiy